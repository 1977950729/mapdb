HTreeMap
===========

HTreeMap provides `HashMap` and `HashSet` collections for MapDB.
Typically it uses tree HashTable with access time ``O(log n)``.
It is thread safe, and supports parallel writes by using multiple segments,
each with separate ReadWriteLock.

HTreeMap supports expiration based on Time-To-Live, maximal number of entries,
and maximal store size. *TODO chapter link*


Create and open
---------------------

HTreeMap has a number of parameters. Most important is **name**, which identifies Map within DB object
and **serializers** which handle data inside Map:

.. literalinclude:: ../src/test/java/doc/htreemap_serializer.java
    :start-after: //a
    :end-before: //z
    :language: java
    :dedent: 8


HTreeMap is recommended for handling large key/values. In same cases you
may want to use compression. Enabling compression store-wide is not
always the best option, since a constantly (de)compressing index tree has overhead.
Instead, it is better to apply compression just to a specific serializer on key or value.
This is done by using serializer wrapper:

.. literalinclude:: ../src/test/java/doc/htreemap_compressed.java
    :start-after: //a
    :end-before: //z
    :language: java
    :dedent: 8
            
Most hash maps uses 32bit hash generated by ``Object.hashCode()`` and check equality with ``Object.equals(other)``. 
However many classes do not implement those functions correctly, and inconsistent hashing is 
very bad for persistence, as it could cause data loss.
By default, configuration HTreeMap uses a generic key serializer and relies on those methods as well.
However, it throws an ``IllegalArgumentException`` if inconsistent hashing is detected (for example ``byte[]``
is used without serializer).

If the specialized Key Serializer is defined, HTreeMap relies on it to provide hash code and equality check
for keys. For example ``Serializer.BYTE_ARRAY`` uses  ``java.util.Arrays.hashCode(byte[])`` to generate hash code.
This way you can use primitive arrays directly as a key/value without a wrapper. 
Bypassing wrappers such as ``String``, improves performance:

.. literalinclude:: ../src/test/java/doc/htreemap_byte_array.java
    :start-after: //a
    :end-before: //z
    :language: java
    :dedent: 8


Another parameter is the **size counter**. By default HTreeMap does not keep
track of its size and calling ``map.size()`` requires a linear scan to count
all entries. You can enable size counter and in that case
``map.size()`` is instant, but there is some overhead on inserts.

.. literalinclude:: ../src/test/java/doc/htreemap_counter.java
    :start-after: //a
    :end-before: //z
    :language: java
    :dedent: 8

And finally some sugar. There is **value creator**, a function to create
a value if the existing value is not found. A newly created value is inserted
into the map. This way ``map.get(key)`` never returns null. This is mainly
useful for various generators and caches.

.. literalinclude:: ../src/test/java/doc/htreemap_value_creator.java
    :start-after: //a
    :end-before: //z
    :language: java
    :dedent: 8





